<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>自旋锁和互斥锁</title><meta name="description" content="流水不争 争的是滔滔不绝"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="互斥锁和自旋锁互斥锁互斥锁是一种独占锁，当线程A加锁成功后，此时互斥锁已经被线程A独占了，只要线程A没有释放手中的锁，线程B就会失败，就会释放掉CPU给其他线程，线程B加锁的代码就会被阻塞。
互斥锁加锁失败而阻塞是由操作系统内核实现的，当加锁失败后，内核将线程置为睡眠状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程加锁成功后就可以继续执行。
互斥锁加锁失败后，会从用户态陷入到内核态，让内核帮助我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。
性能开销成本：两次线程上下文切换的成本。

当线程加锁失败时，内核将线程的状态从【运行】切换到睡眠状态，然后把CPU切换给其他线程运行；
当锁被释放时，之前睡眠状态的线程会变成就绪状态，然后内核就会在合适的时间把CPU切换给该线程运行；

.."><script src="//unpkg.com/valine/dist/Valine.min.js"></script><meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="gxy-littleant's Blog" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">gxy-littleant's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">自旋锁和互斥锁</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E5%92%8C%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-text">互斥锁和自旋锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-text">互斥锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-text">自旋锁</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/%E9%9A%8F%E7%AC%94"><i class="tag post-item-tag">随笔</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">自旋锁和互斥锁</h1><time class="has-text-grey" datetime="2023-05-08T06:35:00.000Z">2023-05-08</time><article class="mt-2 post-content"><h1 id="互斥锁和自旋锁"><a href="#互斥锁和自旋锁" class="headerlink" title="互斥锁和自旋锁"></a>互斥锁和自旋锁</h1><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>互斥锁是一种独占锁，当线程A加锁成功后，此时互斥锁已经被线程A独占了，只要线程A没有释放手中的锁，线程B就会失败，就会释放掉CPU给其他线程，线程B加锁的代码就会被阻塞。</p>
<p>互斥锁加锁失败而阻塞是由操作系统内核实现的，当加锁失败后，内核将线程置为睡眠状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程加锁成功后就可以继续执行。</p>
<p>互斥锁加锁失败后，会从用户态陷入到内核态，让内核帮助我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。</p>
<p>性能开销成本：两次线程上下文切换的成本。</p>
<ol>
<li>当线程加锁失败时，内核将线程的状态从【运行】切换到睡眠状态，然后把CPU切换给其他线程运行；</li>
<li>当锁被释放时，之前睡眠状态的线程会变成就绪状态，然后内核就会在合适的时间把CPU切换给该线程运行；</li>
</ol>
<p>当两个线程属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。</p>
<p>上下切换的耗时大概在几十纳秒到几微秒之间，<strong>如果锁住的代码执行时间比较短，可能上下文切换的时间比锁住的代码执行时间还要长。</strong><br><strong>若是能确定被锁住的代码执行时间很短，就不应该使用互斥锁，而应该选择自旋锁。</strong></p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁通过CPU提供的CAS，在<strong>用户态完成加锁和解锁操作</strong>，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些开销小一些。</p>
<p>加锁过程：<br>● 查看锁的状态，若是空闲的则执行2</p>
<p>● 将锁设置为当前线程持有；使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会忙等待，直到拿到锁。忙等待可以通过while循环实现，不过最好是使用CPU提供的PAUSE指令来实现。</p>
<p>自旋锁利用CPU周期一直自旋直到锁可用。<strong>由于一个自旋的线程永远不会放弃CPU，因此在单核CPU上，需要抢占式的调度器（不断通过时钟中断一个线程，运行其他线程）。</strong></p>
<p>自旋的时间和被锁住的代码执行的时间成正比关系。</p>
<p>当加锁失败，互斥锁使用线程切换应对，自旋锁用忙等待应对。更高级的锁都会选择其中一个实现 </p>
<hr>
<p>一直不理解自旋锁，给我的感觉就是一直占着CPU，不断轮询当前锁是否可用；事实上就是这样，只不过前提条件是多个CPU。<br>在单CPU条件下，需要<strong>抢占式的调度器</strong>，因为自旋锁不会放弃CPU（一直霸占CPU）<br>BTW，美团给个offer吧！求求了~</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/2023/04/03/%E5%80%BC%E5%BE%97%E5%9B%9E%E9%A1%BE%E7%9A%84%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AF%95%E9%A2%98/" title="值得回顾的笔试题"><span class="has-text-weight-semibold">Next: 值得回顾的笔试题</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="https://gxy-littleant.github.io/" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article><article class="mt-6 comment-container" id="vcomments"></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/gxy-littleant"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> gxy-littleant 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>